---
published: true
layout: single
title : "너의 이름은 영화에 나온 MyDiary를 구현한 오픈소스 앱 똑같이 따라 코딩해보기"
category : dev
comments: false
author_profile : true
tag : 
  - Android
  - JAVA
toc : true
---

## Overview

두 달이라는 기간동안 안드로이드 어플리케이션을 개발하기 위해 열중하였고 결국 aintstagram이라는 완성본을 만들게 되었다. 하지만 구현을 하는 도중에 이게 최선의 방법일까라는 고민을 수도 없이 하였고 좀 더 좋은 방법이 분명 존재할 것 같다는 생각을 자주 하게 되었다. 그래서 이번에는 다른 개발자가 구현한 앱의 코드 흐름을 그대로 따라가면서 좀 더 효율적인 코딩을 하기 위한 방법을 배우고자 한다. 

### Target

인스타그램 클론 프로젝트를 구현하는 동안 가장 많이 사용한 것은 RecyclerView와 관련된 내용들이었다. 그래서 이 기능을 활용하는 앱을 따라해보아야겠다는 생각을 하였다. 그리하여 선택한 앱은 MyDiary라는 앱이다.

[MyDiary](https://github.com/DaxiaK/MyDiary)

해당 앱은 너의 이름은 이라는 애니메이션에 등장한 다이어리 어플을 구현한 것으로 MIT 라이센스로 무려 500회가 넘는 커밋기록과 1400개 이상의 star를 받은 작품이다. 해당 앱을 따라하는 과정에서 많은 것들을 배울것으로 확신하고 타겟으로 정하게 되었다. 무엇보다 가장 좋은 점은 따라하는 프로젝트다보니 이미지 관련부분을 고민하지 않아도 된다는 점이다. 물론 코드를 이해해야 겠지만..

## 코딩시작

### InitActivity

어플리케이션을 리버싱 할 때 가장 먼저 확인하는 것이 AndroidManifest였다. 시작점을 찾기가 용이하기 떄문이랄까? 코딩도 마찬가지였다. MAIN 부터 프로그램이 흐름을 따라가기 시작하기 때문에 이를 찾아서 해당 지점부터 구현을 진행하기로 하였다. 매니페스트를 통해 InitActivity가 splash효과를 위해 사용된 것을 확인할 수 있었다. 그 전에 여러 resource 정보들을 추가하기로 하였는데 layout을 제외하고 drawable과 color, 그리고 styles 정보를 복사해왔다. 

InitActivity 쪽을 보니 onCreate부분에서는 핸들러에 대한 초기화와 View에 대한 할당을 진행하는 것 외의 별다른 특징은 보이지 않았다. onCreate -> onStart -> onResume의 단계에서 사용자와의 커뮤니케이션을 시작하는 부분인 onResume에서 SPFManager로부터 메소드를 호출하는 것을 확인할 수 있었다. 이제 SPFManager가 무엇인지를 확인할 차례이다.

SPF는 SharedPreference의 줄임말인듯하다. 왜냐하면 getLocalLanguageCode와 같은 메소드들이 SharedPreference로부터 값을 가져오고 setConfigLocalLanguage 등의 메소드가 SharedPreference의 값을 설정하기 때문이었다.

```java
public static int getLocalLanguageCode(Context context){
    SharedPreferences settings = context.getSharedPreferences(SPF_CONFIG, 0);
    return settings.getInt(CONFIG_LOCAL_LANGUAGE, 0);
}
```    

가져오는 방식은 대부분 동일하였다. settings로 SPF_CONFIG를 가져온 뒤 특정 값을 return으로 넘겨주는 방식이었다. 

```java
public static void setConfigLocalLanguage(Context context, int languageCode){
    SharedPreferences settings = context.getSharedPreferences(SPF_CONFIG, 0);
    SharedPreferences.Editor PE = settings.edit();
    PE.putInt(CONFIG_LOCAL_LANGUAGE, languageCode);

    // Changed it as apply is more faster than commit which means async
    PE.apply();
}
```    

마찬가지로 set도 같은 방식으로 정보를 가져온 뒤 edit를 할 수 있게 Editor를 할당한다. 그 후 putInt와 같은 명령어를 통해 해당 값을 넣어주게 된다. 원본의 코드에서는 PE.commit()이 사용되었는데 해당 예제와 같이 return 값에 대한 처리가 필요하지 않은 경우에는 apply로 바꿈으로써 비동기로 진행하여 더 빠른 처리를 할 수 있다고 한다. 그리하여 apply로 모든 코드를 변경하였다.

```java
protected void onResume() {
    super.onResume();
    //This apk is first install or was updated
    if (SPFManager.getVersionCode(InitActivity.this) < BuildConfig.VERSION_CODE) {
        TV_init_message.setVisibility(View.VISIBLE);
    }
    initHandler.postDelayed(new Runnable() {
        @Override
        public void run() {
            new InitTask(InitActivity.this, InitActivity.this).execute();
        }
    }, initTime);
}
```
InitTask는 onResume 부분에서 initTime인 2500(2.5초)의 대기시간을 가진 뒤 postDelayed에 의해 호출이 된다. InitTask는 AsyncTask를 상속받는데 AsyncTask의 선언방식에 대해서 알아보았다.

```java
public class InitTask extends AsyncTask<Long, Void, Boolean> {
```

3가지 파라미터는 각각 다른 의미를 내포한다. 첫 번째 파라미터는 background 작업에 사용할 data 자료형을 의미하며, background 작업 진행 표시를 위해 사용할 인자가 두 번째 파라미터, 작업의 결과를 표현할 자료형을 세 번째 파라미터로 지정해준다. 

AsyncTask 또한 특정 루틴이 존재하는데 onPreExecuted는 백그라운드 작업이 활성화되기 전에 수행되며 만약 AsyncTask가 이미지 관련 작업을 처리 중인 상태라면 로딩 중임을 표시하는 이미지 띄워넣기 등의 작업을 수행하기 위해 사용된다. 그 후 백그라운드 작업을 수행하게 되는데 doInBackground는 execute를 호출한 당시를 인자로 받아서 수행을 하게 되는데 위 예제에서 context와 callback이 이에 해당된다. 그리고 publishProgress와 같이 진행 상태를 나타내는데 사용되는 메소드들이 존재하며 doInBackground 작업이 마무리되면 onPostExecuted가 호출이 되면서 결과를 리턴해주어 쓰레드 작업이 끝난 뒤의 행동을 수행하도록 한다. 다만 execute의 호출을 UIThread에서 해주어야 되며 Task가 한 번만 실행가능하다는 단점이 있다. 

InitTask에서는 doInBackground 부근에서는 DB로부터 sampleData를 가져오는 역할을 수행하고 onPostExecute는 결과값을 InitCallback 인터페이스의 onInitCompiled 메소드로 반환하게 된다.

doInBackground 부분에서 SQLite DB와 관련된 작업을 수행하는데 이를 위해 db라는 패키지가 존재한다. 안드로이드의 SQLite DataBase는 Contract, Helper, Database로 크게 나뉘는데 Contract는 코드상에서 DBStructure에 해당되며 어떤식으로 계약을 진행할지 나타내는 문서가 되며 Helper는 계약서의 내용을 가져와 CRUD 작업을 수행하며 이를 위한 DB구조가 DBStructure에 명시되어 있다고 보면 된다. 


```java
public class DBStructure {

    public static abstract class DiaryEntry implements BaseColumns {
        public static final String TABLE_NAME = "diary_entry";
        public static final String COLUMN_TIME = "diary_time";
        //Fix  diary_count -> diary_title in V2
        public static final String COLUMN_TITLE = "diary_count";
        public static final String COLUMN_CONTENT = "diary_content";
        public static final String COLUMN_MOOD = "diary_mood";
        public static final String COLUMN_WEATHER = "diary_weather";
        public static final String COLUMN_ATTACHMENT = "diary_attachment";
        public static final String COLUMN_REF_TOPIC__ID = "diary_ref_topic_id";
        public static final String COLUMN_LOCATION = "diary_location";
    }
```

DBStructure 클래스는 BaseColumns로 구현하는데 DiaryEntry에 대한 Column정보를 상수 문자열로 정의해준다. diary_entry라는 이름을 가진 계약서는 time, title, content 등의 컬럼을 가지게 된다. 

```java
private static final String SQL_CREATE_DIARY_ENTRIES =
        "CREATE TABLE " + DiaryEntry.TABLE_NAME + " (" +
                DiaryEntry._ID + INTEGER_TYPE + " PRIMARY KEY AUTOINCREMENT," +
                DiaryEntry.COLUMN_TIME + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_TITLE + TEXT_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_CONTENT + TEXT_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_MOOD + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_WEATHER + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_ATTACHMENT + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_REF_TOPIC__ID + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_LOCATION + TEXT_TYPE + COMMA_SEP +
                FOREIGN + " (" + DiaryEntry.COLUMN_REF_TOPIC__ID + ")" + REFERENCES + TopicEntry.TABLE_NAME + "(" + TopicEntry._ID + ")" +
                " )";
```                    

helper부분을 보면 SQL_CREATE_DIARY_ENTRIES라는 문자열을 볼 수 있는데, DBStructure에서 정의한 값들에 대한 쿼리문을 나태는데 사용된다. 

```java
public void onCreate(SQLiteDatabase db) {
    db.execSQL(SQL_CREATE_TOPIC_ENTRIES);
    db.execSQL(SQL_CREATE_TOPIC_ORDER);

    //Diary V2 work from db version 4
    db.execSQL(SQL_CREATE_DIARY_ENTRIES_V2);
    db.execSQL(SQL_CREATE_DIARY_ITEM_ENTRIES_V2);

    //Add memo order table in version 6
    db.execSQL(SQL_CREATE_MEMO_ENTRIES);
    db.execSQL(SQL_CREATE_MEMO_ORDER);

    db.execSQL(SQL_CREATE_CONTACTS_ENTRIES);
}
```

DBHelper의 onCreate부분을 보면 execSQL로 db에 테이블을 생성해주는데 db상에 이미 존재할 경우 예외가 발생되기 때문에 주의해서 사용하여야 한다.

```java
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (newVersion > oldVersion) {
        try {
            db.beginTransaction();
            if (oldVersion < 2) {
                oldVersion++;
                String addLocationSql = "ALTER TABLE  " + DiaryEntry.TABLE_NAME + " ADD COLUMN " + DiaryEntry.COLUMN_LOCATION + " " + TEXT_TYPE;
                String addTopicOrderSql = "ALTER TABLE  " + TopicEntry.TABLE_NAME + " ADD COLUMN " + TopicEntry.COLUMN_ORDER + " " + INTEGER_TYPE;
                db.execSQL(addLocationSql);
                db.execSQL(addTopicOrderSql);
                db.execSQL(SQL_CREATE_MEMO_ENTRIES);
            }

                //Check update success
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
```

버전의 경우 newVersion과 oldVersion을 확인한 뒤 sql문을 작성하여 execSQL을 하는 것을 확인할 수 있다. 

```java
public void openDB() throws SQLException{
    mDBHelper = new DBHelper(context);
    this.db = mDBHelper.getWritableDatabase();
}

public void closeDB() {
    mDBHelper.close();
}
```

DBManger 부분의 opeDB는 위에서 정의한 Helper를 정의한 뒤 getWritableDatabase()를 호출하여 데이터베이스 객체를 가져온다.

```java
public void beginTransaction(){
    db.beginTransaction();
}

public void setTransactionSuccessful(){
    db.setTransactionSuccessful();
}

public void endTransaction(){
    db.endTransaction();
}
```    

쿼리 작업을 할 때 호출되는 트랜젝션 관련 명령어도 DBManager의 해당 함수들을 호출함으로써 제어하게 된다.

```java
public long insertTopic(String name, int type, int color) {
    return db.insert(
            TopicEntry.TABLE_NAME,
            null,
            this.createTopicCV(name, type, color));
}

public long insertTopicOrder(long topicId, long order) {
    ContentValues values = new ContentValues();
    values.put(TopicOrderEntry.COLUMN_ORDER, order);
    values.put(TopicOrderEntry.COLUMN_REF_TOPIC__ID, topicId);
    return db.insert(
            TopicOrderEntry.TABLE_NAME,
            null,
            values);
}

public long updateTopic(long topicId, String name, int color) {
    ContentValues values = new ContentValues();
    values.put(TopicEntry.COLUMN_NAME, name);
    values.put(TopicEntry.COLUMN_COLOR, color);
    return db.update(
            TopicEntry.TABLE_NAME,
            values,
            TopicEntry._ID + " = ?",
            new String[]{String.valueOf(topicId)});
}
```

Topic과 관련된 메소드들을 보면 ContentValues 인스턴스를 생성하여 put으로 갑들을 넣은 뒤 insert를 통해 db에 삽입을 한다. 

```java
public Cursor selectTopic() {
    Cursor c = db.rawQuery("SELECT * FROM " + TopicEntry.TABLE_NAME
                    + " LEFT OUTER JOIN " + TopicOrderEntry.TABLE_NAME
                    + " ON " + TopicEntry._ID + " = " + TopicOrderEntry.COLUMN_REF_TOPIC__ID
                    + " ORDER BY " + TopicOrderEntry.COLUMN_ORDER + " DESC "
            , null);
    if (c != null) {
        c.moveToFirst();
    }
    return c;
}
```    

selectTopic은 rawQuery라는 명령어로 직접 쿼리문을 작성하였는데 LEFT OUTER JOIN이라는 키워드가 보인다. 

[JOIN의 종류설명](https://coding-factory.tistory.com/87)

이는 테이블이 연관된 경우 교집합, 합집합 등을 가져오기 위한 것으로 LEFT OUTER JOIN을 사용한 위 쿼리는 TopicEntry의 내용을 조회하되 TopicEntry의 ID를 REF_TOPIC_ID로 가지고 있는 TopicOrderEntry들에 대한 값도 같이 가져온다는 의미이며 이렇게 가져온 값을 COLUMN_ORDER를 기준으로 DESC 즉, 내림차 순으로 정렬해서 가져온다는 의미이다. 위의 블로그에서 다이어그램을 확인하면 쉽게 이해가 가능하다.

[FileUtils](https://using.tistory.com/62)

프로젝트 내에서 FileUtils를 활용하여 아래와 같은 처리를 수행하는 코드들이 존재한다.

```java
 FileUtils.deleteDirectory(destDir);
```

apache에서 배포한 것으로 org.apache.commons.io.FileUtils를 import하여 사용할 수 있다. 이를 사용하기 위해서는 gradle에서 implementation을 추가해주면 된다. 현재 버전이 2.7까지 나온것으로 확인되지만 해당 프로젝트에서 사용한 버전이 2.5이기 때문에 이를 사용하도록 한다.

```java
implementation 'commons-io:commons-io:2.5'
```

```java
public class MyDiaryApplication extends Application {

    boolean hasPassword = false;

    @Override
    public void onCreate() {
        super.onCreate();
        //Use Fresco
        Set<RequestListener> listeners = new HashSet<>();
        listeners.add(new RequestLoggingListener());
        ImagePipelineConfig config = ImagePipelineConfig.newBuilder(this)
                .setRequestListeners(listeners)
                .setDownsampleEnabled(true)
                .build();
        Fresco.initialize(this, config);
```    

MyDiaryApplication 부분을 보면 Application으로 정의가 되어 있음을 확인할 수 있다. Application으로 정의된 클래스는 안드로이드 컴포넌트들 사이에서 공유가 가능한 클래스로 공동으로 사용될 항목들을 작성해두면 context를 통해 접근이 가능하다. 그리고 이렇게 생성된 Application은 매니페스트에 정의가 되어 있어야 된다.

Fresco는 페이스북에 만든 라이브러리로 이미지와 관련된 작업을 수행하는데 효율적이다. 캐싱을 지원해서 속도적인 측면에서도 우위를 점할 수 있는데, Application 레벨에서 초기화가 진행되어야 하기 때문에 어플리케이션의 onCreate에 추가되었다. 

```java
AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);
```

AndroidQ부터 NIGHT 시간에는 테마의 색깔이 변하는 설정이 있는데 위의 코드로 해당 기능을 비활성화해준다.

### PasswordActivity

패스워드가 설정된 경우 호출이 되는 액티비티로 주요 기능을 사용자로부터 패스워드를 입력받아 설정 또는 검증을 한다. 방식을 보면 로직은 간단하다. passwordPointer를 두고 사용자로부터 4자리를 입력받는다. 받을 때마다 pos를 옮기면서 조건문을 수행하며 그 과정에서 ImageResource를 입력결과에 따라 변경해준다. PorterDuff를 사용해서 원본이미지가 덮어씌어졌을때 이미지에 대한 처리도 진행한다. 

```java
private void afterPasswordChanged() {
    switch (currentMode) {
        case CREATE_PASSWORD:
            createdPassword = passwordStrBuilder.toString();
            clearUiPassword();
            currentMode = CREATE_PASSWORD_WITH_VERIFY;
            initUI();
            break;
        case CREATE_PASSWORD_WITH_VERIFY:
            if (createdPassword.equals(passwordStrBuilder.toString())) {
                setPassword(Encryption.SHA256(passwordStrBuilder.toString()));
                ((MyDiaryApplication) getApplication()).setHasPassword(true);
                finish();
            } else {
                clearUiPassword();
                setSubMessage();
            }
            break;
```                

Mode에 따라 타는 루틴이 다른데 setPassword부분은 SharedPreference에 패스워드 값을 넣어주는 역할을 한다. 그 인자로 들어가는 값은 사용자로부터 버튼에 클릭된 4자리의 숫자 문자열의 암호화값인데 이를 위해 Encryption이라는 클래스가 존재한다.

```java
public class Encryption {

    public static String Encrypt(String str, String encryptionMethod){
        String encoded;

        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance(encryptionMethod);
            md.update(str.getBytes());
            byte[] byteData = md.digest();
            StringBuffer sb = new StringBuffer();
            for(byte aByteData : byteData){
                sb.append(Integer.toString((aByteData & 0xff) + 0x100, 16).substring(1));
            }
            encoded = sb.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            encoded = null;
        }
        return encoded;
    }
}
```    

Encrypt는 Method정보를 받아서 수행하는데 MD5, SHA-256이 이에 해당된다. 이렇게 받은 정보를 토대로 digest를 수행한 뒤 append를 수행하는데 보면 0xff로 앤드 연산을 처리한 뒤 0x100을 더하고, substring(1)을 하는 행위를 반복한다. 

어떤 행위인지 궁금해서 찾아봤더니 설명된 블로그가 존재하였다.

[byte to hexstrings](https://javaslave.tistory.com/59)

쉽게 설명해서 16진수 값의 범위를 나타내기 위함인데 0x10전까지는 한자리의 값인 0x1, 0xf 등을 가지므로 이를 맞춰주기 위해서 0x101, 0x10f와 같이 만들어준 뒤, 자릿수를 맞추기 위해 맨 앞에 더해진 1을 빼서 0x01, 0x0f와 같이 만들어주는 과정이다. 이를 통해 동일한 자릿수를 만들 수 있다. 이렇게 해쉬화 된 값을 가지고 결과를 확인하는 행위를 하는 액티비티이다.

### MainActivity

PasswordActivity 또는 InitActivity가 호출된 직후에 처리되는 루틴인데 본격적으로 RecyclerView가 사용되기 시작한다. 여기서 참신한 라이브러리를 알게 되는데 android-advancedrecyclerview이다. 직접 구현했던 여러 swipe과 같은 기능들을 오픈소스로 구현해둔 것으로 아래의 깃에서 확인이 가능하다.

[advanced recyclerView](https://github.com/h6ah4i/android-advancedrecyclerview)

ITopic을 자료로 사용하는 MainTopicAdapter 부분을 분해해 볼 차례이다. 

```java
public interface ITopic {
    /**
     * The contacts , Mitsuha  and Taki change their cell phone number in this function.
     */
    int TYPE_CONTACTS = 0;
    /**
     * Mitsuha and Taki write daily diary when their soul change.
     */
    int TYPE_DIARY = 1;

    /**
     * Mitsuha and Taki add some memo to notice that something can't do.
     */
    int TYPE_MEMO = 2;

    String getTitle();

    /**
     * For update topic
     */
    void setTitle(String title);

    int getType();

    long getId();

    @DrawableRes
    int getIcon();

    /**
     * For update count in Main Page
     */
    void setCount(long count);

    long getCount();

    int getColor();

    /**
     * For update topic
     */
    void setColor(int color);

    /**
     * For the left swipe
     */

    void setPinned(boolean pinned);

    boolean isPinned();
}
```

나와는 다르게 interface를 ArrayList로 생성하여 사용하는 것을 확인할 수 있다. 그로 인하여 세부적인 구현에 대한 부분은 존재하지 않는다. 

```java
public MainTopicAdapter(MainActivity activity, List<ITopic> topicList, DBManager dbManager){
    this.activity = activity;
    this.originalTopicList = topicList;
    this.filteredTopicList = new ArrayList<>();
    this.dbManager = dbManager;
}
```

생성자의 경우도 context를 받는게 아닌 명시적으로 어떤 액티비티에서 들어올지를 판단하여 해당 액티비티를 변수로 가지고 있다는 점에서도 차이가 발생한다. 

```java
public class TopicViewHolder extends AbstractSwipeableItemViewHolder {
```

레이아웃과 연결해주는데 사용하는 TopicViewHoler의 정의 부분을 보면 AbstractSwipeableItemViewHolder를 상속받아 라이브러리를 적용한다는 점 또한 확인이 가능하다.

```java
private static class TopicFilter extends Filter {

    private final MainTopicAdapter adapter;
    private final List<ITopic> originalList;
    private final List<ITopic> filteredList;
    private boolean isFilter = false;

    private TopicFilter(MainTopicAdapter adapter, List<ITopic> originalList){
        super();
        this.adapter = adapter;
        this.originalList = originalList;
        this.filteredList = new ArrayList<>();
    }

    @Override
    protected FilterResults performFiltering(CharSequence constraint) {
        filteredList.clear();

        final FilterResults results = new FilterResults();

        if(constraint.length() == 0){
            filteredList.addAll(originalList);
            isFilter = false;
        } else {
            final String filterPattern = constraint.toString().toLowerCase().trim();
            for(final ITopic topic : originalList){
                if(topic.getTitle().toLowerCase().contains(filterPattern)){
                    filteredList.add(topic);
                }
            }
            isFilter = true;
        }
        results.values = filteredList;
        results.count = filteredList.size();
        return results;
    }

    @Override
    protected void publishResults(CharSequence constraint, FilterResults results) {
        adapter.filteredTopicList.clear();
        adapter.filteredTopicList.addAll((ArrayList<ITopic>) results.values);
        adapter.notifyDataSetChanged(false);
    }
```

Filterable은 인스타그램 프로젝트에서도 사용한 적이 있는데 Charsequence를 바탕으로 필터링을 진행하는 performFiltering과 filtering 작업이 끝난뒤에 호출되는 publishResults가 정의되어 있다. 방식은 내 코드와 거의 비슷하다고 봐도 무방한데 filteredPattern에 lowercase로 검색하여 조건에 만족하는 값들을 filteredlist로 옮긴 뒤 기존에 존재하던 filteredTopicList를 지우고 덮어씌우는 역할을 수행한다.

OnCreateViewHolder 부분에서는 RecyclerView의 아이템으로 사용할 레이아웃을 연결하는 작업만 수행하고 onBindViewHolder에서 나와 다르게 onClickListener를 추가해준 것이 확인이 가능하였다. 나라면 TopicViewHolder의 생성자부분에 listener를 달아주었을 것 같다. 아무래도 onBindViewHolder는 Holder를 바꾸는 과정에서 매번 호출이 되기 때문에 한 번만 수행해도 되는 행위가 여러분 수행되기 때문이다. 그래서 나는 다음과 같이 코드를 변경하였다.

```java
@NonNull
@Override
public TopicViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.rv_topic_item, parent, false);
    final TopicViewHolder holder = new TopicViewHolder(view);

    holder.getRLTopic().setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v) {
            gotoTopic(filteredTopicList.get(holder.getAdapterPosition()).getType(), holder.getAdapterPosition());
        }
    });

    holder.getTopicLeftSettingEditView().setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // TODO
        }
    });

    holder.getTopicLeftSettingDeleteView().setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // TODO
        }
    });

    return holder;
}
```    

holder의 position이 직접적으로 들어오지 않기 떄문에 getAdapterPosition을 활용하여 Adapter로부터 위치 정보를 가져오도록 한다. 이렇게 되면 예상치 못하게 pos 정보가 달라지는 경우에도 정확한 위치를 알아낼 수 있다는 장점이 있다. 

```java
@Override
public boolean onCheckCanStartDrag(@NonNull TopicViewHolder holder, int position, int x, int y) {

    final View containerView = holder.getSwipeableContainerView();

    final int offsetX = containerView.getLeft() + (int)(ViewCompat.getTranslationX(containerView) + 0.5f);
    final int offsetY = containerView.getTop() + (int)(ViewCompat.getTranslationY(containerView) + 0.5f);

    return !topicFilter.isFilter() && ViewTools.hitTest(containerView, x-offsetX, y-offsetY);
}
```    

Advanced RecyclerView를 위해서 구현해야 하는 메소드들이 몇개있는데 onCheckCanStartDrag는 행동을 하기 전에 해당 범위에 속해있는지를 검증할 때 사용된다. left좌표와 top의 좌표를 기준으로 holder의 크기 범위안에서 작업이 일어나는지를 확인하여 결과를 돌려준다.

```java
@Override
public void onMoveItem(int fromPosition, int toPosition) {
    if(fromPosition == toPosition) return;

    final ITopic originalItem = originalTopicList.remove(fromPosition);
    originalTopicList.add(toPosition, originalItem);

    final ITopic filteredItem = filteredTopicList.remove(fromPosition);
    filteredTopicList.add(toPosition, filteredItem);

    int orderNumber = originalTopicList.size();
    dbManager.openDB();
    dbManager.deleteAllCurrentTopicOrder();
    for(ITopic topic : originalTopicList){
        dbManager.insertTopicOrder(topic.getId(), --orderNumber);
    }
    dbManager.closeDB();
    notifyDataSetChanged(false);
}
```

MoveEvent의 처리를 위한 방식으로 fromPosition의 값을 뺀 뒤, toPosition 뒤에 삽입한다. 그 후 dbManager를 통해 TopicOrder정보를 삭제한 뒤, 새롭게 추가한 뒤, adapter에 변화를 알리면서 끝을 낸다.

[SwipeableItemAdapter](https://github.com/HIREN4131KINAL/Advance-recycler2/blob/master/library/src/main/java/com/h6ah4i/android/widget/advrecyclerview/swipeable/SwipeableItemConstants.java)

SwipeableItemAdapter 인터페이스를 implements 해주면 마찬가지로 오버라이딩이 필요한 메소드들이 존재한다. 

```java
public int onGetSwipeReactionType(@NonNull TopicViewHolder holder, int position, int x, int y) {
        if (ViewTools.hitTest(holder.getSwipeableContainerView(), x, y)) {
        return SwipeableItemConstants.REACTION_CAN_SWIPE_BOTH_H;
    } else {
        return SwipeableItemConstants.REACTION_CAN_NOT_SWIPE_BOTH_H;
    }
}
```    

위와 같은 메소드인데 해당 enum값은 위의 링크에서 확인이 가능하다. onSetSwipeBackground의 경우 background color 등에 대한 정보를 변경할 수 있다고 한다.

```java
@Nullable
@Override
public SwipeResultAction onSwipeItem(@NonNull TopicViewHolder holder, int position, int result) {
    switch (result){
        case SwipeableItemConstants.RESULT_SWIPED_RIGHT:
            return new SwipeRightResultAction(this, position);
        case SwipeableItemConstants.RESULT_SWIPED_LEFT:
        case SwipeableItemConstants.RESULT_CANCELED:
        default:
            if (position != RecyclerView.NO_POSITION) {
                return new UnpinResultAction(this, position);
            } else {
                return null;
            }                
    }
    return null;
}
```    

onSwipeItem은 swap이벤트에 대한 처리를 담당하는 부분으로 RIGHT인 경우와 LEFT/CANCELED/DEFAULT인 경우로 나누어 처리해준다. 여기서 사용되는 리턴값은 재정의된 클래스이다.

