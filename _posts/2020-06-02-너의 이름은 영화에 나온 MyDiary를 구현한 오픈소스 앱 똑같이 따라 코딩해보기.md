---
published: true
layout: single
title : "너의 이름은 영화에 나온 MyDiary를 구현한 오픈소스 앱 똑같이 따라 코딩해보기"
category : dev
comments: false
author_profile : true
tag : 
  - Android
  - JAVA
toc : true
---

## Overview

두 달이라는 기간동안 안드로이드 어플리케이션을 개발하기 위해 열중하였고 결국 aintstagram이라는 완성본을 만들게 되었다. 하지만 구현을 하는 도중에 이게 최선의 방법일까라는 고민을 수도 없이 하였고 좀 더 좋은 방법이 분명 존재할 것 같다는 생각을 자주 하게 되었다. 그래서 이번에는 다른 개발자가 구현한 앱의 코드 흐름을 그대로 따라가면서 좀 더 효율적인 코딩을 하기 위한 방법을 배우고자 한다. 

### Target

인스타그램 클론 프로젝트를 구현하는 동안 가장 많이 사용한 것은 RecyclerView와 관련된 내용들이었다. 그래서 이 기능을 활용하는 앱을 따라해보아야겠다는 생각을 하였다. 그리하여 선택한 앱은 MyDiary라는 앱이다.

[MyDiary](https://github.com/DaxiaK/MyDiary)

해당 앱은 너의 이름은 이라는 애니메이션에 등장한 다이어리 어플을 구현한 것으로 MIT 라이센스로 무려 500회가 넘는 커밋기록과 1400개 이상의 star를 받은 작품이다. 해당 앱을 따라하는 과정에서 많은 것들을 배울것으로 확신하고 타겟으로 정하게 되었다. 무엇보다 가장 좋은 점은 따라하는 프로젝트다보니 이미지 관련부분을 고민하지 않아도 된다는 점이다. 물론 코드를 이해해야 겠지만..

## 코딩시작

### InitActivity

어플리케이션을 리버싱 할 때 가장 먼저 확인하는 것이 AndroidManifest였다. 시작점을 찾기가 용이하기 떄문이랄까? 코딩도 마찬가지였다. MAIN 부터 프로그램이 흐름을 따라가기 시작하기 때문에 이를 찾아서 해당 지점부터 구현을 진행하기로 하였다. 매니페스트를 통해 InitActivity가 splash효과를 위해 사용된 것을 확인할 수 있었다. 그 전에 여러 resource 정보들을 추가하기로 하였는데 layout을 제외하고 drawable과 color, 그리고 styles 정보를 복사해왔다. 

InitActivity 쪽을 보니 onCreate부분에서는 핸들러에 대한 초기화와 View에 대한 할당을 진행하는 것 외의 별다른 특징은 보이지 않았다. onCreate -> onStart -> onResume의 단계에서 사용자와의 커뮤니케이션을 시작하는 부분인 onResume에서 SPFManager로부터 메소드를 호출하는 것을 확인할 수 있었다. 이제 SPFManager가 무엇인지를 확인할 차례이다.

SPF는 SharedPreference의 줄임말인듯하다. 왜냐하면 getLocalLanguageCode와 같은 메소드들이 SharedPreference로부터 값을 가져오고 setConfigLocalLanguage 등의 메소드가 SharedPreference의 값을 설정하기 때문이었다.

```java
public static int getLocalLanguageCode(Context context){
    SharedPreferences settings = context.getSharedPreferences(SPF_CONFIG, 0);
    return settings.getInt(CONFIG_LOCAL_LANGUAGE, 0);
}
```    

가져오는 방식은 대부분 동일하였다. settings로 SPF_CONFIG를 가져온 뒤 특정 값을 return으로 넘겨주는 방식이었다. 

```java
public static void setConfigLocalLanguage(Context context, int languageCode){
    SharedPreferences settings = context.getSharedPreferences(SPF_CONFIG, 0);
    SharedPreferences.Editor PE = settings.edit();
    PE.putInt(CONFIG_LOCAL_LANGUAGE, languageCode);

    // Changed it as apply is more faster than commit which means async
    PE.apply();
}
```    

마찬가지로 set도 같은 방식으로 정보를 가져온 뒤 edit를 할 수 있게 Editor를 할당한다. 그 후 putInt와 같은 명령어를 통해 해당 값을 넣어주게 된다. 원본의 코드에서는 PE.commit()이 사용되었는데 해당 예제와 같이 return 값에 대한 처리가 필요하지 않은 경우에는 apply로 바꿈으로써 비동기로 진행하여 더 빠른 처리를 할 수 있다고 한다. 그리하여 apply로 모든 코드를 변경하였다.

```java
protected void onResume() {
    super.onResume();
    //This apk is first install or was updated
    if (SPFManager.getVersionCode(InitActivity.this) < BuildConfig.VERSION_CODE) {
        TV_init_message.setVisibility(View.VISIBLE);
    }
    initHandler.postDelayed(new Runnable() {
        @Override
        public void run() {
            new InitTask(InitActivity.this, InitActivity.this).execute();
        }
    }, initTime);
}
```
InitTask는 onResume 부분에서 initTime인 2500(2.5초)의 대기시간을 가진 뒤 postDelayed에 의해 호출이 된다. InitTask는 AsyncTask를 상속받는데 AsyncTask의 선언방식에 대해서 알아보았다.

```java
public class InitTask extends AsyncTask<Long, Void, Boolean> {
```

3가지 파라미터는 각각 다른 의미를 내포한다. 첫 번째 파라미터는 background 작업에 사용할 data 자료형을 의미하며, background 작업 진행 표시를 위해 사용할 인자가 두 번째 파라미터, 작업의 결과를 표현할 자료형을 세 번째 파라미터로 지정해준다. 

AsyncTask 또한 특정 루틴이 존재하는데 onPreExecuted는 백그라운드 작업이 활성화되기 전에 수행되며 만약 AsyncTask가 이미지 관련 작업을 처리 중인 상태라면 로딩 중임을 표시하는 이미지 띄워넣기 등의 작업을 수행하기 위해 사용된다. 그 후 백그라운드 작업을 수행하게 되는데 doInBackground는 execute를 호출한 당시를 인자로 받아서 수행을 하게 되는데 위 예제에서 context와 callback이 이에 해당된다. 그리고 publishProgress와 같이 진행 상태를 나타내는데 사용되는 메소드들이 존재하며 doInBackground 작업이 마무리되면 onPostExecuted가 호출이 되면서 결과를 리턴해주어 쓰레드 작업이 끝난 뒤의 행동을 수행하도록 한다. 다만 execute의 호출을 UIThread에서 해주어야 되며 Task가 한 번만 실행가능하다는 단점이 있다. 

InitTask에서는 doInBackground 부근에서는 DB로부터 sampleData를 가져오는 역할을 수행하고 onPostExecute는 결과값을 InitCallback 인터페이스의 onInitCompiled 메소드로 반환하게 된다.

