---
published: true
layout: single
title : "너의 이름은 영화에 나온 MyDiary를 구현한 오픈소스 앱 똑같이 따라 코딩해보기"
category : dev
comments: false
author_profile : true
tag : 
  - Android
  - JAVA
toc : true
---

## Overview

두 달이라는 기간동안 안드로이드 어플리케이션을 개발하기 위해 열중하였고 결국 aintstagram이라는 완성본을 만들게 되었다. 하지만 구현을 하는 도중에 이게 최선의 방법일까라는 고민을 수도 없이 하였고 좀 더 좋은 방법이 분명 존재할 것 같다는 생각을 자주 하게 되었다. 그래서 이번에는 다른 개발자가 구현한 앱의 코드 흐름을 그대로 따라가면서 좀 더 효율적인 코딩을 하기 위한 방법을 배우고자 한다. 

### Target

인스타그램 클론 프로젝트를 구현하는 동안 가장 많이 사용한 것은 RecyclerView와 관련된 내용들이었다. 그래서 이 기능을 활용하는 앱을 따라해보아야겠다는 생각을 하였다. 그리하여 선택한 앱은 MyDiary라는 앱이다.

[MyDiary](https://github.com/DaxiaK/MyDiary)

해당 앱은 너의 이름은 이라는 애니메이션에 등장한 다이어리 어플을 구현한 것으로 MIT 라이센스로 무려 500회가 넘는 커밋기록과 1400개 이상의 star를 받은 작품이다. 해당 앱을 따라하는 과정에서 많은 것들을 배울것으로 확신하고 타겟으로 정하게 되었다. 무엇보다 가장 좋은 점은 따라하는 프로젝트다보니 이미지 관련부분을 고민하지 않아도 된다는 점이다. 물론 코드를 이해해야 겠지만..

## 코딩시작

### InitActivity

어플리케이션을 리버싱 할 때 가장 먼저 확인하는 것이 AndroidManifest였다. 시작점을 찾기가 용이하기 떄문이랄까? 코딩도 마찬가지였다. MAIN 부터 프로그램이 흐름을 따라가기 시작하기 때문에 이를 찾아서 해당 지점부터 구현을 진행하기로 하였다. 매니페스트를 통해 InitActivity가 splash효과를 위해 사용된 것을 확인할 수 있었다. 그 전에 여러 resource 정보들을 추가하기로 하였는데 layout을 제외하고 drawable과 color, 그리고 styles 정보를 복사해왔다. 

InitActivity 쪽을 보니 onCreate부분에서는 핸들러에 대한 초기화와 View에 대한 할당을 진행하는 것 외의 별다른 특징은 보이지 않았다. onCreate -> onStart -> onResume의 단계에서 사용자와의 커뮤니케이션을 시작하는 부분인 onResume에서 SPFManager로부터 메소드를 호출하는 것을 확인할 수 있었다. 이제 SPFManager가 무엇인지를 확인할 차례이다.

SPF는 SharedPreference의 줄임말인듯하다. 왜냐하면 getLocalLanguageCode와 같은 메소드들이 SharedPreference로부터 값을 가져오고 setConfigLocalLanguage 등의 메소드가 SharedPreference의 값을 설정하기 때문이었다.

```java
public static int getLocalLanguageCode(Context context){
    SharedPreferences settings = context.getSharedPreferences(SPF_CONFIG, 0);
    return settings.getInt(CONFIG_LOCAL_LANGUAGE, 0);
}
```    

가져오는 방식은 대부분 동일하였다. settings로 SPF_CONFIG를 가져온 뒤 특정 값을 return으로 넘겨주는 방식이었다. 

```java
public static void setConfigLocalLanguage(Context context, int languageCode){
    SharedPreferences settings = context.getSharedPreferences(SPF_CONFIG, 0);
    SharedPreferences.Editor PE = settings.edit();
    PE.putInt(CONFIG_LOCAL_LANGUAGE, languageCode);

    // Changed it as apply is more faster than commit which means async
    PE.apply();
}
```    

마찬가지로 set도 같은 방식으로 정보를 가져온 뒤 edit를 할 수 있게 Editor를 할당한다. 그 후 putInt와 같은 명령어를 통해 해당 값을 넣어주게 된다. 원본의 코드에서는 PE.commit()이 사용되었는데 해당 예제와 같이 return 값에 대한 처리가 필요하지 않은 경우에는 apply로 바꿈으로써 비동기로 진행하여 더 빠른 처리를 할 수 있다고 한다. 그리하여 apply로 모든 코드를 변경하였다.

```java
protected void onResume() {
    super.onResume();
    //This apk is first install or was updated
    if (SPFManager.getVersionCode(InitActivity.this) < BuildConfig.VERSION_CODE) {
        TV_init_message.setVisibility(View.VISIBLE);
    }
    initHandler.postDelayed(new Runnable() {
        @Override
        public void run() {
            new InitTask(InitActivity.this, InitActivity.this).execute();
        }
    }, initTime);
}
```
InitTask는 onResume 부분에서 initTime인 2500(2.5초)의 대기시간을 가진 뒤 postDelayed에 의해 호출이 된다. InitTask는 AsyncTask를 상속받는데 AsyncTask의 선언방식에 대해서 알아보았다.

```java
public class InitTask extends AsyncTask<Long, Void, Boolean> {
```

3가지 파라미터는 각각 다른 의미를 내포한다. 첫 번째 파라미터는 background 작업에 사용할 data 자료형을 의미하며, background 작업 진행 표시를 위해 사용할 인자가 두 번째 파라미터, 작업의 결과를 표현할 자료형을 세 번째 파라미터로 지정해준다. 

AsyncTask 또한 특정 루틴이 존재하는데 onPreExecuted는 백그라운드 작업이 활성화되기 전에 수행되며 만약 AsyncTask가 이미지 관련 작업을 처리 중인 상태라면 로딩 중임을 표시하는 이미지 띄워넣기 등의 작업을 수행하기 위해 사용된다. 그 후 백그라운드 작업을 수행하게 되는데 doInBackground는 execute를 호출한 당시를 인자로 받아서 수행을 하게 되는데 위 예제에서 context와 callback이 이에 해당된다. 그리고 publishProgress와 같이 진행 상태를 나타내는데 사용되는 메소드들이 존재하며 doInBackground 작업이 마무리되면 onPostExecuted가 호출이 되면서 결과를 리턴해주어 쓰레드 작업이 끝난 뒤의 행동을 수행하도록 한다. 다만 execute의 호출을 UIThread에서 해주어야 되며 Task가 한 번만 실행가능하다는 단점이 있다. 

InitTask에서는 doInBackground 부근에서는 DB로부터 sampleData를 가져오는 역할을 수행하고 onPostExecute는 결과값을 InitCallback 인터페이스의 onInitCompiled 메소드로 반환하게 된다.

doInBackground 부분에서 SQLite DB와 관련된 작업을 수행하는데 이를 위해 db라는 패키지가 존재한다. 안드로이드의 SQLite DataBase는 Contract, Helper, Database로 크게 나뉘는데 Contract는 코드상에서 DBStructure에 해당되며 어떤식으로 계약을 진행할지 나타내는 문서가 되며 Helper는 계약서의 내용을 가져와 CRUD 작업을 수행하며 이를 위한 DB구조가 DBStructure에 명시되어 있다고 보면 된다. 


```java
public class DBStructure {

    public static abstract class DiaryEntry implements BaseColumns {
        public static final String TABLE_NAME = "diary_entry";
        public static final String COLUMN_TIME = "diary_time";
        //Fix  diary_count -> diary_title in V2
        public static final String COLUMN_TITLE = "diary_count";
        public static final String COLUMN_CONTENT = "diary_content";
        public static final String COLUMN_MOOD = "diary_mood";
        public static final String COLUMN_WEATHER = "diary_weather";
        public static final String COLUMN_ATTACHMENT = "diary_attachment";
        public static final String COLUMN_REF_TOPIC__ID = "diary_ref_topic_id";
        public static final String COLUMN_LOCATION = "diary_location";
    }
```

DBStructure 클래스는 BaseColumns로 구현하는데 DiaryEntry에 대한 Column정보를 상수 문자열로 정의해준다. diary_entry라는 이름을 가진 계약서는 time, title, content 등의 컬럼을 가지게 된다. 

```java
private static final String SQL_CREATE_DIARY_ENTRIES =
        "CREATE TABLE " + DiaryEntry.TABLE_NAME + " (" +
                DiaryEntry._ID + INTEGER_TYPE + " PRIMARY KEY AUTOINCREMENT," +
                DiaryEntry.COLUMN_TIME + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_TITLE + TEXT_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_CONTENT + TEXT_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_MOOD + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_WEATHER + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_ATTACHMENT + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_REF_TOPIC__ID + INTEGER_TYPE + COMMA_SEP +
                DiaryEntry.COLUMN_LOCATION + TEXT_TYPE + COMMA_SEP +
                FOREIGN + " (" + DiaryEntry.COLUMN_REF_TOPIC__ID + ")" + REFERENCES + TopicEntry.TABLE_NAME + "(" + TopicEntry._ID + ")" +
                " )";
```                    

helper부분을 보면 SQL_CREATE_DIARY_ENTRIES라는 문자열을 볼 수 있는데, DBStructure에서 정의한 값들에 대한 쿼리문을 나태는데 사용된다. 

```java
public void onCreate(SQLiteDatabase db) {
    db.execSQL(SQL_CREATE_TOPIC_ENTRIES);
    db.execSQL(SQL_CREATE_TOPIC_ORDER);

    //Diary V2 work from db version 4
    db.execSQL(SQL_CREATE_DIARY_ENTRIES_V2);
    db.execSQL(SQL_CREATE_DIARY_ITEM_ENTRIES_V2);

    //Add memo order table in version 6
    db.execSQL(SQL_CREATE_MEMO_ENTRIES);
    db.execSQL(SQL_CREATE_MEMO_ORDER);

    db.execSQL(SQL_CREATE_CONTACTS_ENTRIES);
}
```

DBHelper의 onCreate부분을 보면 execSQL로 db에 테이블을 생성해주는데 db상에 이미 존재할 경우 예외가 발생되기 때문에 주의해서 사용하여야 한다.

```java
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (newVersion > oldVersion) {
        try {
            db.beginTransaction();
            if (oldVersion < 2) {
                oldVersion++;
                String addLocationSql = "ALTER TABLE  " + DiaryEntry.TABLE_NAME + " ADD COLUMN " + DiaryEntry.COLUMN_LOCATION + " " + TEXT_TYPE;
                String addTopicOrderSql = "ALTER TABLE  " + TopicEntry.TABLE_NAME + " ADD COLUMN " + TopicEntry.COLUMN_ORDER + " " + INTEGER_TYPE;
                db.execSQL(addLocationSql);
                db.execSQL(addTopicOrderSql);
                db.execSQL(SQL_CREATE_MEMO_ENTRIES);
            }

                //Check update success
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
```

버전의 경우 newVersion과 oldVersion을 확인한 뒤 sql문을 작성하여 execSQL을 하는 것을 확인할 수 있다. 

```java
public void openDB() throws SQLException{
    mDBHelper = new DBHelper(context);
    this.db = mDBHelper.getWritableDatabase();
}

public void closeDB() {
    mDBHelper.close();
}
```

DBManger 부분의 opeDB는 위에서 정의한 Helper를 정의한 뒤 getWritableDatabase()를 호출하여 데이터베이스 객체를 가져온다.

```java
public void beginTransaction(){
    db.beginTransaction();
}

public void setTransactionSuccessful(){
    db.setTransactionSuccessful();
}

public void endTransaction(){
    db.endTransaction();
}
```    

쿼리 작업을 할 때 호출되는 트랜젝션 관련 명령어도 DBManager의 해당 함수들을 호출함으로써 제어하게 된다.

```java
public long insertTopic(String name, int type, int color) {
    return db.insert(
            TopicEntry.TABLE_NAME,
            null,
            this.createTopicCV(name, type, color));
}

public long insertTopicOrder(long topicId, long order) {
    ContentValues values = new ContentValues();
    values.put(TopicOrderEntry.COLUMN_ORDER, order);
    values.put(TopicOrderEntry.COLUMN_REF_TOPIC__ID, topicId);
    return db.insert(
            TopicOrderEntry.TABLE_NAME,
            null,
            values);
}

public long updateTopic(long topicId, String name, int color) {
    ContentValues values = new ContentValues();
    values.put(TopicEntry.COLUMN_NAME, name);
    values.put(TopicEntry.COLUMN_COLOR, color);
    return db.update(
            TopicEntry.TABLE_NAME,
            values,
            TopicEntry._ID + " = ?",
            new String[]{String.valueOf(topicId)});
}
```

Topic과 관련된 메소드들을 보면 ContentValues 인스턴스를 생성하여 put으로 갑들을 넣은 뒤 insert를 통해 db에 삽입을 한다. 

```java
public Cursor selectTopic() {
    Cursor c = db.rawQuery("SELECT * FROM " + TopicEntry.TABLE_NAME
                    + " LEFT OUTER JOIN " + TopicOrderEntry.TABLE_NAME
                    + " ON " + TopicEntry._ID + " = " + TopicOrderEntry.COLUMN_REF_TOPIC__ID
                    + " ORDER BY " + TopicOrderEntry.COLUMN_ORDER + " DESC "
            , null);
    if (c != null) {
        c.moveToFirst();
    }
    return c;
}
```    

selectTopic은 rawQuery라는 명령어로 직접 쿼리문을 작성하였는데 LEFT OUTER JOIN이라는 키워드가 보인다. 

[JOIN의 종류설명](https://coding-factory.tistory.com/87)

이는 테이블이 연관된 경우 교집합, 합집합 등을 가져오기 위한 것으로 LEFT OUTER JOIN을 사용한 위 쿼리는 TopicEntry의 내용을 조회하되 TopicEntry의 ID를 REF_TOPIC_ID로 가지고 있는 TopicOrderEntry들에 대한 값도 같이 가져온다는 의미이며 이렇게 가져온 값을 COLUMN_ORDER를 기준으로 DESC 즉, 내림차 순으로 정렬해서 가져온다는 의미이다. 위의 블로그에서 다이어그램을 확인하면 쉽게 이해가 가능하다.

[FileUtils](https://using.tistory.com/62)

프로젝트 내에서 FileUtils를 활용하여 아래와 같은 처리를 수행하는 코드들이 존재한다.

```java
 FileUtils.deleteDirectory(destDir);
 ```

 apache에서 배포한 것으로 org.apache.commons.io.FileUtils를 import하여 사용할 수 있다. 이를 사용하기 위해서는 gradle에서 implementation을 추가해주면 된다. 현재 버전이 2.7까지 나온것으로 확인되지만 해당 프로젝트에서 사용한 버전이 2.5이기 때문에 이를 사용하도록 한다.

 ```java
 implementation 'commons-io:commons-io:2.5'
 ```

 