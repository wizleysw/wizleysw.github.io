---
published: true
layout: single
title : "Activity에 대한 이야기"
category : android
comments: false
author_profile : true
tag : 
  - Android
toc : true
---

## OverView

안드로이드 4대 컴포넌트 요소이며 내가 생각하기에 가장 기본이 되는 내용이다. Google Developer Docs를 보면 액티비티는 한 앱이 다른 앱을 호출할 때 앱 자체를 호출하는게 아니라 특정 행동을 호출하기 때문에 Activity라는 표현을 사용한다고 한다. 예로 facebook을 하다가 내부에서 email앱을 호출하는 것과 비슷한 경우를 들 수 있다. 

액티비티가 다른 컴포넌트와 다른 점은 UI를 표시한다는 것이다. 즉 사용자와 상호작용을 위해 사용되는 구성요소라고 할 수 있다. 사용자 인터페이스를 포함한 화면 하나 하나가 한 개의 Activity가 되는데 이런 특징 때문에 특정 앱의 Activity를 호출하는 행위가 가능해진다. 액티비티는 여러 화면이 합쳐진 형태를 띄기도 하는데 Fragment 등을 활용하여 화면을 행위별로 구분지어 분리한 경우가 이에 해당한다. 

## Life Cycle

위와 같이 각각의 액티비티가 한 화면을 이루기 때문에 화면의 전환이 잦아지면 속도의 저하 및 메모리 이슈가 발생할 수 있다. 효율적으로 자원을 관리하기 위해서 Activity 인스턴스는 생명 주기인 Life Cycle에 따라 동작하며 화면 생성, 일시 정지 등의 상태에 대한 콜백을 제공하여 Activity의 상태 변화에 따른 변화를 효율적으로 관리한다.

예제를 들어보자면 웹툰을 보고있는 도중에 친구로부터 전화가 걸려오는 경우 전화앱으로 전환이 이루어지게 되는데 이 때 웹툰에 대한 Life Cycle이 잘못구현되어 있을 경우 비정상 종료를 할 수 있다. 또한 여러가지 앱이 켜져있을 경우 메모리 관리가 제대로 이루어지지 않을 경우, 특정 앱이 원할하게 작동하지 않을 수 있다. 즉, 데이터의 손실이 이루어져 취약해지거나 크래시가 발생할 수 있다. 이런 문제를 해결하기 위해서 LifeCycle을 정의하여 모든 Activity의 서브 클래스는 해당 행위를 따라 작동한다.

![life_cycle](https://developer.android.com/guide/components/images/activity_lifecycle.png)

Activity는 생명 주기로 6가지 상태가 제공되는데 onCreate, onStart, onResume, onPause, onStop, onDestroy가 이에 해당된다. Activity가 처음 생성되는 순간부터 행위를 끝마쳐 종료되는 시점까지의 과정에서 앞의 6가지 생명 주기를 모두 거치게 된다. 위의 공식 문서상의 다이어그램을 보면 상태에 따라 변경되는 대략적인 모습을 확인 가능한데 백그라운드로 전환되거나 다른 앱의 메모리가 부족하여 가비지 컬렉션이 진행된 앱이 재 실행되는 경우와 같은 여러 상황들에 대한 과정이 그려져있다. Activity는 특수한 경우를 제외하고는 Background가 아닌 Foreground에서 작동한다. 그렇기 때문에 여러 Activity가 켜져있을 경우 Android는 그 상태를 확인하여 메모리에서 제거 등의 행위를 할 때 대상으로 선정하게 된다. 

### onCreate

Activity가 최초로 생성될 때 호출이 되며 콜백은 필수적으로 구현되어야 된다. 또한 생명 주기 동안 맨 처음 딱 한번만 생성되기 때문에 한 번만 수행해야 되는 코드들에 해당 부분에 위치하여야 한다. 대표적으로 Layout 데이터들을 변수로 초기화하거나 Listener를 설정하는 행위들이 이에 해당된다. 

```java
public class LifeCycle extends Activity {
    private static final String VALUE = "";
    Button btn;
    String value;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if(savedInstanceState != null){
            value = savedInstanceState.getString(VALUE);
        }

        setContentView(R.layout.activity_lifecycle);

        btn = (Button) findViewById(R.id.button);
    }

    @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        btn.setText(savedInstanceState.getString(VALUE));
        super.onRestoreInstanceState(savedInstanceState);
    }

    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        outState.putString(VALUE, value);
        super.onSaveInstanceState(outState);
    }
}
```

위으 코드는 xml로 정의된 레이아웃 사용자 인터페이스를 설정하고 멤버 변수를 설정하는 방법을 보여주는 예제이다. 

![layout](https://developer.android.com/images/viewgroup_2x.png)

개발자 문서의 레이아웃 부분을 보면 레이아웃은 앱에서 사용자 인터페이스를 위한 구조를 정의하는 것으로 모든 요소들은 View와 ViewGroup 객체의 계층을 사용하여 빌드된다고 한다. View는 사용자가 보고 상호작용할 수 있는 Button, TextView 등을 의미하고 ViewGroup은 레이아웃이라고도 불리는 다양한 구조를 제공하는 LinearLayout, ConstraintLayout 등을 의미한다. 

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:name="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:text="LifeCycle" />

</RelativeLayout>
```

onCreate에서 호출되는 setContentView의 파라미터인 R.layout.activity_lifecycle가 위의 xml 파일을 일컫는데 RelativeLayout ViewGroup의 내부에 Button이라는 View 객체를 가지고 있음을 알 수 있다. 앱이 컴파일을 진행할 때 XML 레이아웃 파일이 View 리소스 안에 컴파일 되게 되는데 onCreate 콜백에서 앱 코드로부터 레이아웃 리소르를 로드해야 된다. setContentView가 호출이 되면 레이아웃 리소스에 대한 참조가 전달되어 액티비티에 로드되게 된다. 

findViewById는 이렇게 지정된 레이아웃의 View를 찾아서 연결해줄 때 사용되는데 Button 객체의 name이 button이기 때문에 findViewById(R.id.button) 의 형태로 접근하여 Button 객체에 초기화를 수행해주는 것이다. 초기화 부분 역시 해당 Activity가 실행되는 동안 단 한번만 수행하면 되기 때문에 onCreate부분에서 수행해주는 것이 좋다. 

onCreate의 파라미터로는 Bundle 타입의 savedInstanceState 매개변수가 넘어오는데 Activity의 이전 저장 상태가 포함되어 있는 객체이다. 이는 onPause, onStop 등의 상태에서 메모리가 부족한 상황등에 의하여 정리될 경우에 앱이 다시 실행되면 onCreate로 돌아오게 되는데, 이 때 onSaveInstanceState를 호출하여 저장이 필요한 값들에 대한 백업을 진행한다. onRestoreInstanceState는 값을 복구하는 단계에서 호출이 되며 메모리에서 정리된 값들을 백업한 값들을 토대로 다시 복구해준다. 

Activity가 처음 시작하는 순간에는 백업할 데이터가 없기 때문에 특수한 경우를 제외하고는 null 값이 넘어오게 된다. 

### onStart

Activity가 시작되는 상태로 사용자에게 보이게 되는 순간이다. 이 부분에 도달하게 되면 Activity를 포그라운드에 배치하여 사용자와 상호작용을 할 수 있도록 준비하게 된다. ON_START 이벤트를 수신하게 되면 그 즉시 실행되고 사용자와 상호작용을 하지는 않고 있는 상태라고 볼 수 있다. 

```java
@Override
protected void onStart() {
    super.onStart();
}
```

onCreate와 달리 onStop 상태에서 onRestart에 의해 다시 실행될 수 있기 때문에 onStop 이후 화면을 표시해줄 때 변경되어야 할 부분이 있다면 해당 부분을 정의할 수 있다. 

### onResume

바로 이 상태가 사용자와 상호작용을 시작하는 그 순간이다. 특정 이벤트가 발생하여서 앱에서 Activity에 대한 포커스가 사라지는 그 순간까지 이 상태에 머물러있게 된다. 즉, 전화가 오거나 다른 앱이 실행되거나 또는 화면이 꺼지는 경우 등이 발생하기 전까지는 onResume 상태에서 지속적으로 사용자와 상호작용을 하고 있다는 의미이다. 

만약 이 상태에서 시그널 또는 이벤트가 발생하게 되면 Activity는 일시정지 상태로 들어가게 되어 onPause 상태가 된다. 해당 Activity위로 팝업창 등이 떠있어서 사용자의 포커스가 팝업창으로 이동한 상태의 경우가 이에 속하는데 팝업 창을 지우고 다시 Activity 화면으로 돌아오면 onResume이 재호출 되고 홈 버튼을 눌러서 화면에서 Activity가 사라지게 되면 onStop 상태가 된다. 

여기서 조금 모호한 점이 있었는데 onStart와 onResume의 차이를 짚고 넘어가는 것이 좋겠다. 둘 다 사용자가 화면을 볼 수는 있지만 실질적으로 사용자가 이벤트를 발생시킬 수 있는 단계는 onResume 단계이다. 

좀 더 세부적인 차이로 들어가자면 멀티 윈도우를 예로 들 수 있다. Developer Docs에 따르면 멀티 윈도우 환경일 경우 topmost Activity 만이 onResume 상태를 가지고 있고 나머지는 onStart 상태를 가지고 있다고 한다. 예를 들어서 사용자가 문서를 작성하는 동안에도 옆의 창에서는 youtube 영상이 재생되고 있을 확률이 있다. 이런 경우 youtube가 topmost 앱이 아니기 때문에 그 상태는 onstart로 남아서 사용자와 상호작용을 하지는 않지만 영상을 눈으로 볼 수 있게 되는 것이다. 이렇기에 기본적인 life cycle에 따라 onPause가 호출되었을 때 동영상을 정지하게 되면 onStart로 전환된 topmost가 아닌 youtube와 같은 앱들에 대한 동작이 정상적이지 않을 수 있다. 그렇기에 onStop 부분에 정지와 같은 처리를 하는 것을 권고한다고 한다. 

### onPause

앞에서 설명했듯이 Activity가 포그라운드에 존재하지 않는 경우 onPause가 호출이 된다. (멀티 윈도우 모드에서는 보일 수 있음) onPause는 잠ㅁ시 후 다시 해당 Activity를 실행할 가능성이 높기 때문에 작업을 일시정지하는 코드들이 주로 배치된다. 

하지만 onPause는 정말 잠깐 실행도기 때문에 저장 작업을 수행하여서는 안된다. 즉, onPause 부분에서 데이터를 저장하거나, 네트워크 호출을 하거나, DB 작업을 하면 메서드의 실행이 끝나기 전에 완료되지 못할 수 있기 때문에 부하가 큰 작업은 onStop 상태일 때 실행해야 된다. onPause는 사용자에게 완전히 보이지 않을 때까지 머무르며 이 상태에서 다시 Activity가 실행되면 onResume이 호출되게 된다. 만약 화면이 전환되거나 화면에서 Activity가 완전히 보이지 않게 되면 onStop이 호출된다.

### onStop

Activity 화면이 노출되어 있지 않으면 onStop 상태에 진입하며 다른 Activity가 화면 전체를 차지하고 있음을 의미한다. 해당 부분에서는 앱이 사용자에게 보이지 않는 동안 필요하지 않은 리소스를 해제하거나 조정하게 되는데 애니메이션을 정지시키거나 위치에 대한 정보를 바꾸는 행위들이 이에 해당된다. 이 또한 멀티 윈도우 환경에서는 사용자에게 UI 작업이 변경되는 것이 확인 된다. onPause와 다르게 onStop에서는 CPU를 많이 사용하는 작업들에 대한 종료를 수행해야 되는데 DB에 저장하는 행위들을 하기에 적합하다. 

만약 Activity가 다시 실행되면 onRestart가 호출이 되며 메모리가 부족하여 killed된 경우에는 onCreate를 호출하게 된다. 메모리 정리에도 우선순위가 존재하는데 프로세스의 상태와 Activity 상태에 따라 우선순위가 주어진다.

종료될 가능성이 가장 높은 경우는 onStop/onDestroy 상황이며 그 다음으로는 onPause 상태가 되며 나머지 상태는 적은 가능성을 가진다. 

### onDestroy

Activity가 종료되는 시기에 호출이 되는데 2가지 경우를 통해 호출이 된다. 첫 경우는 코드 상에서 finish()가 호출되거나 Activity를 닫는 경우이며, 다른 한 경우는 기기의 방향이 회전되어 뷰를 다시 구성해야 되는 경우 등으로 인하여 Android에 의해 일시적으로 소멸되는 경우이다. 

### LifeCycleObserver / LifeCycleOwner

눈으로 직접 행위를 확인하기 위해서 Observer를 사용한다. 위에서 언급했듯이 각각의 생명 주기에 따라 event가 발생하기 떄문에 이를 캐치해서 로그를 찍어보도록 하자.

```java

public class CustomLifeCycleObserver implements LifecycleObserver {

    private final static String TAG = "LifecycleObserver";

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    public void onCreate(){
        Log.e(TAG, "onCreate");
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    public void onStart(){
        Log.e(TAG, "onStart");
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume(){
        Log.e(TAG, "onResume");
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause(){
        Log.e(TAG, "onPause");
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    public void onStop(){
        Log.e(TAG, "onStop");
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy(){
        Log.e(TAG, "onDestroy");
    }
}
```

각각의 상태에 대한 Event가 발생하면 Log가 찍히도록 하였다.

```java
public class LifeCycleActivity extends Activity implements LifecycleOwner {

    private static final String VALUE = "";
    Button btn;
    String value;

    private LifecycleRegistry lifecycleRegistry;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if(savedInstanceState != null){
            value = savedInstanceState.getString(VALUE);
        }

        lifecycleRegistry = new LifecycleRegistry(this);
        lifecycleRegistry.addObserver(new CustomLifeCycleObserver());
        lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED);

        setContentView(R.layout.activity_lifecycle);

        btn = (Button) findViewById(R.id.button);
    }

    @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        btn.setText(savedInstanceState.getString(VALUE));
        super.onRestoreInstanceState(savedInstanceState);
    }

    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        outState.putString(VALUE, value);
        super.onSaveInstanceState(outState);
    }

    @Override
    protected void onStart() {
        super.onStart();

        lifecycleRegistry.setCurrentState(Lifecycle.State.STARTED);
    }

    @Override
    protected void onResume() {
        super.onResume();

        lifecycleRegistry.setCurrentState(Lifecycle.State.RESUMED);
    }

    @Override
    protected void onPause() {
        super.onPause();

        lifecycleRegistry.setCurrentState(Lifecycle.State.STARTED);
    }

    @Override
    protected void onStop() {
        super.onStop();

        lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        lifecycleRegistry.setCurrentState(Lifecycle.State.DESTROYED);
    }

    @Override
    protected void onRestart() {
        super.onRestart();

        lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED);
    }

    @NonNull
    @Override
    public Lifecycle getLifecycle() {
        return lifecycleRegistry;
    }
}
```

LifeCycle 액티비티에서 생명주기를 몽땅 오버라이딩 하여 Observer에 state 변경을 알리는 코드를 삽입하였다. 여러 작업을 수행하고 나서 아래와 같은 log 기록을 확인할 수 있었다.

```
2020-06-12 21:01:39.035 24485-24485/wizley.android.playground E/LifecycleObserver: onCreate
2020-06-12 21:01:39.054 24485-24485/wizley.android.playground E/LifecycleObserver: onStart
2020-06-12 21:01:39.059 24485-24485/wizley.android.playground E/LifecycleObserver: onResume
2020-06-12 21:01:42.265 24485-24485/wizley.android.playground E/LifecycleObserver: onPause
2020-06-12 21:01:44.009 24485-24485/wizley.android.playground E/LifecycleObserver: onResume
2020-06-12 21:01:47.265 24485-24485/wizley.android.playground E/LifecycleObserver: onPause
2020-06-12 21:01:47.941 24485-24485/wizley.android.playground E/LifecycleObserver: onStop
2020-06-12 21:01:52.610 24485-24485/wizley.android.playground E/LifecycleObserver: onStart
2020-06-12 21:01:52.611 24485-24485/wizley.android.playground E/LifecycleObserver: onResume
```

복습하는 의미에서 생각을 해보면 onCreate를 통해서 최초로 Activity가 생성이 되고 레이아웃 및 초기화 작업이 수행된다. 그 후 onStart로 진입하는데 사용자에게 화면이 보여지지만 상호작용은 하지 않고 있다. onResume이 호출되는 그 순간 사용자와 상호작용을 시작하고 Activity가 최상단에 위치하게 된다. 그러다 팝업이 뜨게 되면 onPause 상태가 되고 이는 포커스를 잃었음을 의미한다. 그 상태에서 팝업을 없애고 다시 Activity가 최상단에 위치하게 되면 onResume 상태로 돌아가게 된다. 

여기서 홈 버튼을 누름으로써 onPause에서 onStop이 호출되게 되고 이는 Activity가 화면에 보이지 않는 상태임을 의미한다. 다시 해당 Activity로 돌아오게 될 때 RAM 상태에 따라 Activity가 정리된 경우에는 onCreate부터 다시 호출이 되지만 해당 실습에서는 onRestart를 걸쳐 onStart가 호출이 된다. 그 후 다시 상호작용을 위한 단계인 OnResume이 호출된 것을 확인할 수 있다.

